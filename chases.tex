\section{Présentation des chaînages avant (\textit{chase})}\label{sec:types_de_chases}

% Le chaînage avant est une stratégie de calcul des réponses à une requête $\mathcal{Q}$. On part du corps d'une règle pour déduire de nouveaux faits présent dans la tête de la règle. Le chaînage avant peut s'appliquer en largeur et en profondeur.

Dans cette partie différents types de chaînages avant vont être présentés. On va ici s'intéresser à une catégorie particulière de chaînage en avant, celui en largeur : on applique toutes les règles à partir d'une base de faits $\mathcal{F}_i$ pour obtenir une base de faits $\mathcal{F}_{i+1}$ à partir de laquelle on ré-applique toutes les règles, et ainsi de suite jusqu'à saturation. 
\par Mais avant de présenter différentes variantes du chaînage avant en largeur, nous devons construire une base commune à tous ces $chases$ en vue notamment de leur implémentation future. Ainsi, on présente un algorithme de chaînage avant en largeur suffisamment générique (section \ref{subsec:algo_base_ch_avant}) pour qu'il soit la base de tous les types de chaînages avant  que nous allons présenter  (section \ref{subsec:types_chases}).

% \begin{definition}[chaînage avant en largeur]
% A chaque itération du chaînage avant, toutes les règles candidates sont déclenchées.
% \end{definition}

% \begin{definition}[chaînage avant en profondeur]
% A chaque itération du chaînage avant, seule la première règle candidate est déclenchée.
% \end{definition}

% \begin{definition}[Saturation d'une base de faits]
% Soit une base de connaissances $\mathcal{K} = (\mathcal{F}, \mathcal{R})$. Saturer $\mathcal{F}$
% consiste à calculer la base de faits saturée $\mathcal{F^*}$ obtenue en appliquant de manière itérative les règles de $\mathcal{R}$ sur $\mathcal{F}$ jusqu'à stabilité (on ne déduit pas de nouveaux faits).   
% \end{definition}

%\begin{definition}[Saturation finie/infinie]
%\par On dit que si la saturation $\mathcal{F}^*$ est finie alors il existe $k \in \mathbb{N}$ borné tel que $\mathcal{F}_k$ = $\mathcal{F^*}$.
%De même on dit que si la saturation $\mathcal{F^*}$ est infinie alors il n'existe pas de borne pour un tel $k$.   
%\end{definition}

% \begin{definition}[Modèle universel]
% Si il existe un modèle universel $\mathcal{M}$ pour une base de connaissance $\mathcal{K}$ alors, tout modèle $\mathcal{M}_i$ de $\mathcal{K}$ admet un homomorphisme $h$ tel que $h(\mathcal{M}_i)$ = $\mathcal{M}$.   

%\end{definition}

\subsection{Algorithme de base}\label{subsec:algo_base_ch_avant}

%Commençons tout d'abord par définir la notion de déclencheur (ou \textit{trigger}) : il s'agit d'un couple $(R = B \rightarrow H,h)$ où $R$ est une règle et $h$ un homomorphisme permettant d'envoyer $B$, le corps de la règle $R$, sur la base de faits.
%\par Un déclencheur est dit nouveau si il n'a pas été trouvé lors d'une étape précédente du chaînage avant en largeur.
%\par Il est dit applicable si il respecte le critère d'applicabilité, qui diffère en fonction du type de chaînage en avant. La variation du critère d'applicabilité d'une règle n'a d'intérêt que pour les règles existentielles. En effet, avec les règles Datalog, les chaînages avant s'arrêtent toujours tandis que l'arrêt avec les règles existentielles varie en fonction des critères d'applicabilité des règles utilisés.

Avant de décrire l'algorithme générique de chaînage avant, il convient de décrire deux sous-algorithmes utilisés par celui-ci : l'extension locale et l'extension globale. Ces deux sous-algorithmes permettent d'introduire la flexibilité dans l'implémentation de différents types de chaînage avant.

\par Une extension locale est un algorithme qui prend en paramètre les nouveaux faits de l'étape en cours et un déclencheur applicable et qui produit des nouveaux faits à partir du déclencheur pour les ajouter aux nouveaux faits de l'étape en cours - cet algorithme varie en fonction du type de \textit{chase}.
\par Une extension globale est un algorithme prenant en paramètre la base de faits de l'étape précédente et les nouveaux faits de l'étape en cours et qui produit la base de faits de l'étape en cours - il varie lui aussi en fonction du type de \textit{chase}.
\par Ceci posé, on peut décrire notre algorithme de chaînage avant en largeur (algorithme  \ref{algo:chainage_avant_largeur}).
Soit une base de connaissances $\mathcal{KB} = (\mathcal{F}_0, \mathcal{R})$. Une étape de chaînage avant en largeur  consiste, à partir d'une base de faits $\mathcal{F}_i$ à générer une base de faits $\mathcal{F}_{i+1}$ en :
\begin{itemize}
    \item Ajoutant le contenu de $\mathcal{F}_{i}$ à $\mathcal{F}_{i+1}$ ;
    \item Pour chaque règle $R = B \rightarrow H \in \mathcal{R}$, trouver tous les nouveaux déclencheurs $(R,h)$ tels que $h(B) \subset \mathcal{F}_i$ ;
    \item Tester si le déclencheur $(R,h)$ est applicable, et si il l'est, faire une extension locale des nouveaux faits $h(H)$ ;
    \item Une fois toutes les règles appliquées, réaliser l'extension globale.
\end{itemize}

% \par De même, l'algorithme \ref{algo:chainage_avant_largeur} n'explique comment la base de faits est étendue à chaque étape, cela est précisé dans l'algorithme \ref{algo:etendre_general} pour tous les chaînages avant à l'exception de certains comme le \textit{core chase} qui a sa propre méthode d'extension de la base de faits.
% \par De même, lors de chaque application de règle, il y a une extension dite locale consistant à sélectionner les nouveaux faits qui seront fournis à l'extension globale. La version par défaut est l'algorithme \ref{algo:etendre_local_defaut}.

%\paragraph{Homomorphisme sûr} Un homomorphisme $h^s$ est une extension d'un homomorphisme $h$ consistant à remplacer les variables de l'ensemble d'atomes sur lequel est appliqué $h^s$ par des noms de variables "frais", autrement dit des noms de variables n'existant pas encore dans la base de faits que l'on sature.
%\newline

\begin{algorithm}[!h]\label{algo:chainage_avant_largeur}
\setstretch{1}
\caption{Chaînage avant en largeur}
\SetAlgoLined
\DontPrintSemicolon

\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{une base de faits $\mathcal{F}$, une base de règles $\mathcal{R}$}
\Output{la base de faits saturée $\mathcal{F^*}$}
\SetKwRepeat{Do}{faire}{tant que}

$\mathcal{F}_0 \gets \mathcal{F}$\;
$n \gets 0$\;

\Do{$nouvFait \not= \emptyset$}
{
    $nouvFaits\gets \emptyset$ \;
    \ForEach{règle : $ R = B \rightarrow  H \in \mathcal{R}$} 
    {
        \ForEach{déclencheur $(R,h)$} 
        {
            \uIf{$estApplicable(R,h)$}
            {
                $nouvFaits \leftarrow \mbox{\textit{étendreLocalement}}(nouvFaits, (R,h))$\;
            }
        }
    }
    $\mathcal{F}_{n+1} \gets \mbox{\textit{étendreGlobalement}}(\mathcal{F}_{n}, nouvFaits)$\;
    $n \gets n + 1$\;
}
\Return $\mathcal{F}_n$
\end{algorithm}

Maintenant que la base commune aux différents types de \textit{chase} a été posée, on va pouvoir les présenter.

\subsection{Types de \textit{chases}}\label{subsec:types_chases}

Cette partie a pour objet de présenter tous les chases qui ont été implémentés dans le cadre du projet.
\par Quatres de ces chases sont "classiques" dans la littérature scientifique du domaine. Dans l'ordre de leur capacité à éviter les redondances : l'\textit{oblivious chase}\cite{Cali:2013:TIC:2591248.2591252} (\ref{sec:oblivious_chase}), le \textit{semi-oblivious chase}\cite{Marnette:2009:GST:1559795.1559799} (\ref{sec:semi_oblivious_chase}), le \textit{restricted chase}\cite{FAGIN200589} (\ref{sec:restricted_chase}) et le \textit{core chase}\cite{Deutsch:2008:CR:1376916.1376938} (\ref{sec:core_chase}). 
 Deux autres chases, proposés par Stathis Delivorias, un doctorant de l'équipe GraphiK, vont aussi être présentés : le \textit{local core chase} (\ref{sec:local_core_chase}) et le \textit{vacuum chase} (\ref{sec:vacuum_chase}).

\subsubsection{L'Oblivious \textit{chase}}\label{sec:oblivious_chase}

L'\textit{oblivious chase} est le type de chaînage avant générant le plus de redondances. Il ne fait en effet aucun filtre pour les éliminer : un déclencheur est considéré comme étant toujours applicable à partir du moment qu'il n'a pas été déjà été trouvée à une étape précédente (algorithme \ref{algo:est_applicable_oblivious}).
\par Ce faisant, ses propriétés d'arrêt sont médiocres sur les règles existentielles, et il est donc facile de trouver des cas où l'algorithme ne s'arrête pas.
\par Au niveau de l'extension locale (algorithme \ref{algo:etendre_local_oblivious}), l'algorithme se contente d'ajouter aux nouveaux faits le résultat de l'application du déclencheur (définition \ref{def:application_declencheur}).
\par Quant à l'extension globale (algorithme \ref{algo:etendre_global_oblivious}), elle se contente d'ajouter les nouveaux faits à la base de faits.


\begin{algorithm}[!h]\label{algo:est_applicable_oblivious}
\setstretch{1}
\caption{estApplicable (\textit{Oblivious})}
\SetAlgoLined
\DontPrintSemicolon
\SetKw{Break}{break}
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$(R,h)$ : un déclencheur
\par $L$ : la liste des déclencheurs des étapes précédentes}
\Output{vrai si le déclencheur $(R,h)$ est applicable au sens de l'\textit{oblivious chase}}
\uIf{$(R,h) \in L$}
{
    \Return $faux$
}
\Else{
    \Return $vrai$
}
\end{algorithm}

\begin{algorithm}[H]\label{algo:etendre_local_oblivious}
\setstretch{1}
\caption{étendreLocalement (\textit{Oblivious})}
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{
   $nouvFaits$ : les nouveaux faits de l'étape en cours
    \par $(R = B \rightarrow H,h)$ : le déclencheur à appliquer}
\Output{l'extension de $nouvFaits$}
    \Return $nouvFaits \cup h^{safe}(H)$ \Comment{voir définition \ref{def:application_declencheur}}
\end{algorithm}

\begin{algorithm}[H]\label{algo:etendre_global_oblivious}
\setstretch{1}
\caption{étendreGlobalement (\textit{Oblivious})}
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$\mathcal{F}$ : la base de faits à étendre
\par $nouvFaits$ : les nouveaux faits de l'étape en cours}
\Output{la base de faits $\mathcal{F'}$ étendue}
    $\mathcal{F'} \gets \mathcal{F} \cup nouvFaits$\;
    \Return $\mathcal{F'}$
\end{algorithm}

Pour illustrer cet algorithme prenons un exemple où il s'arrête : soit la base de connaissances $\mathcal{KB}_A = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(X,Y) \rightarrow q(X,Z) \})$.
\begin{center}
\begin{tabular}{|c|c|}
    \hline
    Étape & Base de faits  \\ 
    \hline
    1 &$\mathcal{F} \cup \{q(a, Z_1)\}$ \\ 
    \hline
    2 &$\mathcal{F}_1$  \\
    \hline
\end{tabular}
\end{center}
On constate que l'algorithme s'arrête à la deuxième étape.
\par Prenons un exemple ou l'\textit{oblivious chase} ne s'arrête pas. Soit
$\mathcal{KB}_B = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(X,Y) \rightarrow p(X,Z) \})$

\begin{center}
\begin{tabular}{|c|c|}
    \hline
    Étape & Base de faits  \\ 
    \hline
    1 &$\mathcal{F} \cup \{p(a, Z_1)\}$ \\ 
    \hline
    2 &$\mathcal{F}_1 \cup \{p(a, Z_2)\}$ \\
    \hline
    ... & ... \\
    \hline
    $i+1$ & $\mathcal{F}_i \cup \{p(a, Z_{i+1})\} $ \\
    \hline
\end{tabular}
\end{center}

On constate bien que la saturation ne s'arrête jamais : la règle produit un atome redondant qui permet de la ré-appliquer à l'infini. Le \textit{semi-oblivious chase} va permettre d'éviter que l'algorithme ne s'arrête pas dans ce type de cas.

\subsubsection{Le \textit{semi-oblivious chase}}\label{sec:semi_oblivious_chase}

%L'algorithme du Semi-Oblivious \textit{chase} est très proche de l'Oblivious Chase, comme ce dernier il n'applique une règle $R$ par rapport à un homomorphisme $h$ qu'une seule fois, mais en plus il compare aussi les frontières de l'homomorphisme $h$ avec les frontières des éléments de la base de faits. Si il en trouve des identiques alors $h$ n'est pas ajouté à la base de faits.%

% \begin{definition}[Déclencheur]
% Soit une base de connaissances $\mathcal{K} = (\mathcal{F}, \mathcal{R})$ et $R$ une règle tel que $R \in \mathcal{R}$ de la forme $B \rightarrow  H$.
% Un couple $(R,h)$ est un déclencheur pour $\mathcal{F}$ si $h$ est un homomorphisme de $B$ dans $\mathcal{F}$.
% \end{definition}

L'algorithme du Semi-Oblivious \textit{chase} a un critère d'applicabilité plus strict que l'\textit{oblivious chase} (algorithme \ref{algo:est_applicable_semi_oblivious}). 
\par Comme pour l'\textit{oblivious chase}, on retient une liste $L$ de tous les déclencheurs appliqués précédemment. Lorsque l'on veut tester si un déclencheur $(R,h)$ est applicable, alors on recherche dans $L$ si il existe un déclencheur $(R,g)$ tel que $h(frontier(R)) = g(frontier(R))$ (définition \ref{def:frontier}). Si c'est le cas, la règle n'est pas applicable, sinon elle l'est.
\par L'idée ici est que, si les substitutions $h$ et $g$ envoient la frontière sur les mêmes variables, alors les atomes produits par $h^{safe}(H)$ seront forcément redondants par rapport à ceux de $g^{safe}(H)$ car ils seront isomorphes.
\par Les algorithmes d'extension sont les mêmes que ceux de l'\textit{oblivious chase}.

\begin{proposition}
    Si l'\textit{oblivious chase} s'arrête, alors le \textit{semi-oblivious} s'arrête aussi.
\end{proposition}

\begin{proof} Le \textit{semi-oblivious chase} a une condition sur la frontière en plus il aura donc au pire la même efficacité que l'\textit{oblivious}.
\end{proof}

\setstretch{1}
\begin{algorithm}[H]\label{algo:est_applicable_semi_oblivious}
\caption{estApplicable (Semi-Oblivious)}
\SetAlgoLined
\DontPrintSemicolon
\SetKw{Break}{break}
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$(R,h)$ : le déclencheur à tester
\par $L$ : la liste des déclencheurs précédemment appliqués}
\Output{vrai si le déclencheur $(R,h)$ est applicable au sens du \textit{semi-oblivious chase}}
    \uIf{il existe $(R,g) \in L$ tel que $h(frontier(R)) = g(frontier(R))$}
    {
        \Return faux
    }
\Return $vrai$
\end{algorithm}
\setstretch{1.5}
Illustrons maintenant l'algorithme en reprenant l'exemple où l'\textit{oblivious chase} ne s'arrête pas.
\par Soit $\mathcal{KB}_B = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(X,Y) \rightarrow p(X,Z) \})$

\begin{center}
\begin{tabular}{|c|c|c|}
    \hline
    $\mathcal{F}$ & Oblivious & Semi-oblivious \\ 
    \hline
    1 &$\mathcal{F} \cup \{p(a, Z_1)\}$ & $\mathcal{F} \cup \{p(a, Z_1)\} $\\ 
    \hline
    2 &$\mathcal{F}_1 \cup \{p(a, Z_2)\}$ &$\mathcal{F}_1$\\
    \hline
    ... & ... & \\
    \hline
    $i+1$ & $\mathcal{F}_i \cup \{p(a, Z_{i+1})\} $& \\
     \hline
     ... & ... & \\
     \hline
\end{tabular}
\end{center}

Ici, le semi-oblivious chase termine la saturation lors de la deuxième étape car le seul nouveau délencheur trouvé $(R,\{X \rightarrow a$, $Y \rightarrow Z_1\})$ a le même effet sur la frontière (qui ne contient que $X$) que le déclencheur $(R,\{X \rightarrow a$, $Y \rightarrow b\})$ appliqué lors de la première étape.  

\par Cependant, c'est un algorithme pour lequel il reste facile de trouver des exemples dans lesquels il ne s'arrête pas.
Soit $\mathcal{KB}_C = (\mathcal{F} = \{p(a,a)\}, \mathcal{R} = \{R = p(X,Y) \rightarrow p(Y,Z) \})$

\begin{center}
\begin{tabular}{|c|c|}
    \hline
    $\mathcal{F}$ & Semi-oblivious \\ 
    \hline
    1  & $\mathcal{F} \cup \{p(a, Z_1)\} $ \\ 
    \hline
    2  &$\mathcal{F}_1 \cup \{p(Z_1, Z_2)\}$  \\
    \hline
    ...  & ...  \\
    \hline
    i+1 & $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $   \\
     \hline
     ...  & ...  \\
     \hline
\end{tabular}
\end{center}
C'est pour cela que l'on va introduire le \textit{restricted chase}.

\subsubsection{Le \textit{restricted chase}}\label{sec:restricted_chase}

Le \textit{restricted chase} a une approche différente pour éviter les redondances. Pour décider si un déclencheur $(R = B \rightarrow H,h)$ est applicable, on va tester l'existence d'une substitution $h'$ telle que $h \subset h'$ et $h'(H) \subset \mathcal{F}$, $\mathcal{F}$ étant la base de faits. Si un tel $h'$ existe, alors on n'applique pas le déclencheur. L'idée ici est que, si $h'$ existe, alors les atomes produits à l'aide de ce déclencheur seront forcément redondants par rapport à la base de faits puisque il existe des atomes équivalents au nom des variables près.
\par Le critère du \textit{restricted chase} est plus puissant que celui du \textit{semi-oblivious chase}. En effet, dans le \textit{semi-oblivious chase}, si il existe un déclencheur ayant le même effet sur la frontière de la règle qu'un déclencheur appliqué précédemment, alors ce déclencheur précédent a produit des atomes qui sont dans la base de faits et par rapport auxquels le nouveau déclencheur produira forcément des atomes redondants, que le critère du \textit{restricted chase} sera en mesure de détecter. Par conséquent, si un \textit{semi-oblivious chase} s'arrête, alors le \textit{restricted chase} s'arrête aussi.
\par Les extensions locale et globale restent quant à elles les mêmes que pour les deux algorithmes précédents.
\par Concernant le critère d'applicabilité, il y a deux façons de l'utiliser : soit la base de faits sur laquelle on fait le test est la base de faits courante de l'étape en cours ($\mathcal{F}_n$), et dans ce cas on dira que le \textit{restricted chase} est parallèle (algorithme \ref{algo:est_applicable_restricted_parallel}). Soit il s'agit de base de faits courante à laquelle on ajoute les nouveaux faits produits dans l'étape en cours ($\mathcal{F}_n \cup nouvFaits$) et dans ce cas, on parlera de \textit{restricted chase} en largeur (algorithme \ref{algo:est_applicable_restricted_largeur}).

\begin{algorithm}[!h]\label{algo:est_applicable_restricted_parallel}
\setstretch{1}
\caption{estApplicable (\textit{restricted chase} en parallèle)}
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$(R,h)$ : le déclencheur à tester
\par $\mathcal{F}_n$ : la base de faits courante }
\Output{vrai si le déclencheur $(R,h)$ est applicable au sens du \textit{restricted chase} en parallèle}
    \uIf{il existe $h'$ tel que $h \subset h'$ et $h'(H) \subset \mathcal{F}$}
    {
        \Return $faux$
    }
\Return $vrai$
\end{algorithm}
\begin{algorithm}[H]\label{algo:est_applicable_restricted_largeur}
\setstretch{1}
\caption{estApplicable (\textit{restricted chase} en largeur)}
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$(R,h)$ : le déclencheur à tester
\par $\mathcal{F}_n$ : la base de faits courante
\par $nouvFaits$ : les nouveaux faits obtenus durant l'étape courante}
\Output{vrai si le déclencheur $(R,h)$ est applicable au sens du \textit{restricted chase} en largeur}
    \uIf{il existe $h'$ tel que $h \subset h'$ et $h'(H) \subset \mathcal{F} \cup nouvFaits$}
    {
        \Return $faux$
    }
\Return $vrai$
\end{algorithm}
\setstretch{1.5}
\par La version largeur est susceptible de produire moins de redondances que la version parallèle, car elle peut permettre d'éviter des redondances produites par d'autres règles durant la même étape. Cependant, elle présente le défaut d'être non-déterministe : en effet, le résultat du chaînage avant va différer en fonction de l'ordre d'application des règles, comme cela est illustré dans l'exemple \ref{ex:restricted_largeur_non_deterministe}.

\begin{example}
% oblivious , expl 3
$\mathcal{KB}_C = (\mathcal{F} = \{p(a,a)\}, \mathcal{R} = \{R = p(X,Y) \rightarrow p(Y,Z) \})$

\begin{center}
\begin{tabular}{|c|c|c|c|}
    \hline
    $\mathcal{F}$ & Oblivious & Semi-oblivious & Restricted \\ 
    \hline
    1 &$\mathcal{F} \cup \{p(a, Z_1)\}$ & $\mathcal{F} \cup \{p(a, Z_1)\} $&  $\mathcal{F}$ \\ 
    \hline
    2 &$\mathcal{F}_1 \cup \{p(Z_1, Z_2)\}$ &$\mathcal{F}_1 \cup \{p(Z_1, Z_2)\}$ & \\
    \hline
    ... & ... & ... & \\
    \hline
    i+1 & $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $& $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $&   \\
     \hline
     ... & ... & ... & \\
     \hline
\end{tabular}
\end{center}
\end{example}

Ici, le \textit{restricted chase} termine la saturation lors de la première étape étape car le seul homomorphisme trouvé $h = (X \rightarrow a, Y \rightarrow a)$ peut être étendu en $h' = (X \rightarrow a, Y \rightarrow a, Z \rightarrow a)$ tel que $h'(p(Y,Z)) = p(a,a) \in \mathcal{F}$. 

\begin{example}\label{ex:restricted_largeur_non_deterministe}
% oblivious , expl 4
$\mathcal{KB}_D = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R_1 = p(X,Y) \rightarrow p(Y,Z) , R_2 = p(X,Y) \rightarrow p(Y,Y) \})$

\begin{center}
% \begin{tabular}{|c|c|c|}
%     \hline
%     $\mathcal{F}$ & Oblivious & Semi-oblivious \\ 
%     \hline
%     1 &$\mathcal{F} \cup \{p(b, z_1), p(b,b)\}$ & $\mathcal{F} \cup \{p(b, z_1), p(b,b)\} $\\ 
%     \hline
%     2 &$\mathcal{F}_1 \cup \{p(z_1, z_2), p(z_1, z_1), p(b, z_3)\}$ &$\mathcal{F}_1 \cup \{p(z_1, z_2), p(z_1, z_1)\}$  \\
%     \hline
%     ... & ... & ...  \\
%     \hline
%     i+1 & $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1}), p(z_{i}, z_{i}), p(z_{i-1}), p(z_{i+2}), ...\} $& $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1}), p(z_{i}, z_{i})\} $ \\
%      \hline
%      ... & ... & ... \\
%      \hline
% \end{tabular}
\begin{tabular}{|c|c|c|c|c|}
    \hline
    $\mathcal{F}$ & \textit{restricted chase} en parallèle & \textit{restricted chase} en largeur ($R_1$ / $R_2$) & \textit{restricted chase} en largeur ($R_2$ / $R_1$)  \\ 
    \hline
    1 &  $\mathcal{F} \cup \{p(b, Z_1), p(b,b)\} $ &  $\mathcal{F} \cup \{p(b, Z_1), p(b,b)\} $ & $\mathcal{F} \cup \{p(b,b)\}$ \\ 
    \hline
    2 &$\mathcal{F}_1 \cup \{p(Z_1, Z_2), p(Z_1, Z_1)\}$ &$\mathcal{F}_1 \cup \{p(Z_1, Z_2), p(Z_1, Z_1)\}$& $\mathcal{F}_1$ \\
    \hline
    ... & ... & ... &  \\
    \hline
    i+1 &  $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1}), p(Z_{i}, Z_{i})\} $   &  $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1}), p(Z_{i}, Z_{i})\} $  & \\
     \hline
     ... & ... &  ... &  \\
     \hline
\end{tabular}
\end{center}
\end{example}

Dans cet exemple, l'ordre d'application des règles modifie le résultat de la saturation. Lorsque l'on utilise l'ordre $R_1$/$R_2$ la saturation est infinie, alors qu'avec l'ordre $R_2$/$R_1$, la saturation se termine lors de la deuxième étape. Le \textit{restricted chase} en parallèle donne le même résultat que celui en largeur avec l'ordre $R_1$/$R_2$.
\par Cet exemple nous permet aussi de constater que le \textit{restricted chase} est lui-aussi susceptible de produire des redondances et de ne pas s'arrêter pour cette raison. Le type de \textit{chase} qui suit ne produit quant à lui aucune redondance.

\subsubsection{Le \textit{core chase}}\label{sec:core_chase}

Le \textit{core chase} est un chaînage avant qui consiste, lors de chaque étape en largeur, à calculer le \textit{core} de la base faits courante afin de supprimer toute redondance (algorithme \ref{algo:etendre_core_chase}).
Cela a pour conséquence que, si une base de connaissances possède un modèle universel fini, alors le \textit{core chase} s'arrête en un nombre fini d'étapes.
\par Le \textit{core chase} utilise l'algorithme d'extension locale de l'\textit{oblivious chase} et le critère d'applicabilité du \textit{restricted chase}. Autant la version parallèle que celle en largeur peuvent être utilisées : en effet, il n'y a pas de problème de résultat modifié par l'ordre d'application des règles puisque toutes les redondances sont supprimées à la fin de chaque étape. Le résultat d'une étape sera toujours isomorphe au résultat de la même étape obtenu avec un autre ordre d'application des règles.

\setstretch{1}
\begin{algorithm}[!h]\label{algo:etendre_core_chase}
\caption{étendreGlobalement (\textit{core chase})}
\SetAlgoLined
\DontPrintSemicolon
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$\mathcal{F}$ : la base de faits à étendre
\par $nouvFaits$ : nouveaux faits produits durant l'étape courante}
\Output{la base de faits $\mathcal{F'}$ étendue}
    $\mathcal{F'} \gets \mathcal{F} \cup nouvFaits$\;
    $\mathcal{F'} \gets Core(\mathcal{F'})$\;
    \Return $\mathcal{F'}$
\end{algorithm}

\begin{example}
% oblivious , expl 4
$\mathcal{KB}_D = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R_1 = p(X,Y) \rightarrow p(Y,Z) , R_2 = p(X,Y) \rightarrow p(Y,Y) \})$

\begin{center}
\begin{tabular}{|c|c|c|c|}
    \hline
    $\mathcal{F}$ & \textit{restricted chase} en parallèle & \textit{core chase} \\ 
    \hline
    1 &  $\mathcal{F} \cup \{p(b, Z_1), p(b,b)\} $ & $\mathcal{F} \cup \{ p(b,b)\}$\\ 
    \hline
    2 &$\mathcal{F}_1 \cup \{p(Z_1, Z_2), p(Z_1, Z_1)\}$ & $\mathcal{F}_1$ \\
    \hline
    ... & ... & \\
    \hline
    i+1 &  $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1}), p(Z_{i}, Z_{i})\} $  & \\
     \hline
     ... &  ...  & \\
     \hline
\end{tabular}
\end{center}
\end{example}

Contrairement au \textit{restricted chase} en parallèle, dans cet exemple, la saturation avec le \textit{core chase} se termine, et en seulement deux étapes. Cette différence est due au fait que $p(b, z_1)$ est enlevé de la base faits lors du calcul du \textit{core}, car il est redondant par rapport à $p(b, b)$.

%exemple 5 
\begin{example}
$\mathcal{KB}_E = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(X,Y) \rightarrow p(Y,Z) \})$
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
    \hline
    $\mathcal{F}$ & \textit{oblivious chase} & \textit{semi-oblivious chase} & \textit{restricted chase} & \textit{core chase} \\ 
    \hline
    1 & $\mathcal{F} \cup \{p(b, Z_0)\} $& $\mathcal{F} \cup \{p(b, Z_0)\}$ &  $\mathcal{F} \cup \{p(b, Z_0)\}$ &  $\mathcal{F} \cup \{p(b, Z_0)\}$\\
    \hline
    2 & $\mathcal{F}_1 \cup \{p(Z_0, Z_1)\}$ & $\mathcal{F}_1 \cup \{p(Z_0, Z_1)\} $& $\mathcal{F}_1 \cup \{p(Z_0, Z_1)\}$ & $\mathcal{F}_1 \cup \{p(Z_0, Z_1)\}$\\ 
    \hline
    3 & $\mathcal{F}_2 \cup \{p(Z_1, Z_2)\}$ & $\mathcal{F}_2 \cup \{p(Z_1, Z_2)\}$ &  $\mathcal{F}_2 \cup \{p(Z_1, Z_2)\}$ & $\mathcal{F}_2 \cup \{p(Z_1, Z_2)\}$\\ 
    \hline
    ... &... & ... & ... & ...\\
    \hline
    i+1 & $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $& $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $& $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $  & $\mathcal{F}_i \cup \{p(Z_{i}, Z_{i+1})\} $\\
    \hline
    ... &... & ... & ... & ...\\
    \hline
    %\mathcal{F}_2 = \mathcal{F}_1 \cup \{p(a, z_2)\} & \mathcal{F}_2 = \mathcal{F}_1 & &\\
    %\hline
    %\mathcal{F}_{i+1} = \mathcal{F}_i \cup \{p(a, z_{i+1})\} &  & & \\
     %\hline
\end{tabular}
\end{center}
\end{example}

La base de faits $\mathcal{KB}_E$ ne possède pas de modèle fini et de ce fait, aucun des algorithmes de chaînage avant ne termine.

\par Si le \textit{core chase} possède d'excellentes propriétés d'élimination des redondances, il est souvent plus lent que les algorithmes présentés précédemment, hormis dans les cas où les autres types de chaînage avant ne s'arrêtent pas. En effet, le calcul du \textit{core} est une opération coûteuse : il s'agit d'un problème co-NP-complet. À cela s'ajoute le fait que ce calcul est effectué sur la base de faits entière, dont la taille peut vite devenir importante lors de la saturation.
\par C'est pour essayer de palier à ce défaut que les deux algorithmes qui suivent ont été imaginés. Il s'agit d'essayer de trouver un compromis entre propriétés de suppression des redondances (et donc aussi d'arrêt du chaînage avant) et vitesse de saturation.

\subsubsection{Le \textit{local core chase}}\label{sec:local_core_chase}

Le \textit{local core chase} est aussi un chaînage avant qui fait appel à un calcul du \textit{core}, mais de manière plus restreinte. En effet, lors de l'extension globale, au lieu de simplement calculer le \textit{core} de la base de faits, on va d'abord geler la base de faits (c'est-à-dire transformer les variables en constantes), y ajouter les nouveaux faits pour ensuite faire le calcul du \textit{core} et enfin dégeler les variables (algorithme \ref{algo:etendre_local_core_chase}). La complexité du calcul du \textit{core} est en effet en fonction du nombre de variables susceptibles de s'envoyer un autre terme. Transformer certaines variables en constantes réduit donc le temps de calcul du \textit{core}.
\par Le gel des variables va avoir pour conséquence que les éléments pré-existants dans la base de faits ne pourront subir de repliement, seules les redondances se trouvant dans les nouveaux faits pourront être supprimées.
\par Comme pour le \textit{core chase}, le critère d'applicabilité est celui du \textit{restricted chase} et l'extension locale celle de l'\textit{oblivious chase}.
\begin{algorithm}[!h]\label{algo:etendre_local_core_chase}
\setstretch{1}
\caption{étendreGlobalement (\textit{local core chase})}
\SetAlgoLined
\DontPrintSemicolon
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$\mathcal{F}$ : la base de faits courante
\par $nouvFaits$ : les nouveaux faits à ajouter}
\Output{la base de faits $\mathcal{F'}$ étendue}
% freeze -> union -> Core -> defreeze
	$\mathcal{F'} \gets freeze(\mathcal{F}, nouvFaits)$\;
    $\mathcal{F'} \gets core(\mathcal{F'})$\;
    \Return $unfreeze(\mathcal{F'})$
\end{algorithm}
\par Cet algorithme va être illustré par deux exemples : à l'aide de la base $\mathcal{KB}_D$ vue précédemment, sur laquelle le \textit{core chase} s'arrête mais pas forcément le \textit{restricted chase}. Et d'une autre base de connaissances sur laquelle le \textit{core chase} s'arrête mais pas le \textit{local core chase}.

\begin{example}
$\mathcal{KB}_D = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R_1 = p(X,Y) \rightarrow p(Y,z) , R_2 = p(X,Y) \rightarrow p(Y,Y) \})$

\begin{center}
\begin{tabular}{|c|c|c|c|}
    \hline
    $\mathcal{F}$ & \textit{local core chase} & \textit{core chase} \\ 
    \hline
    1 & $\mathcal{F} \cup \{ p(b,b)\}$ & $\mathcal{F} \cup \{ p(b,b)\}$\\ 
    \hline
    2 & $\mathcal{F}_1$ & $\mathcal{F}_1$ \\
     \hline
\end{tabular}
\end{center}

On constate sur cet exemple que les deux algorithmes se comportent de la même façon. Mais ce n'est pas toujours le cas comme on va le voir dans l'exemple qui suit.
\end{example}

\begin{example}
$\mathcal{KB}_F = (\mathcal{F} = \{r(a)\}, \mathcal{R} = \{R_1 = r(X) \rightarrow p(X,Z), R_2 = p(X,Y) \rightarrow p(X,Z) \land p(Z,Z), R_3 = p(X,Y) \rightarrow p(Y,Z) \})$
\begin{center}
\begin{tabular}{|c|c|c|c|}
    \hline
    $\mathcal{F}$ & \textit{local core chase} & \textit{core chase} \\ 
    \hline
    1 & $\mathcal{F} \cup \{ p(a,Z_1)\}$ & $\mathcal{F} \cup \{ p(a,Z_1)\}$\\ 
    \hline
    2  & $\mathcal{F}_1 \cup \{p(a, Z_2), p(Z_2, Z_2), p(Z1, Z_3)\}$ & $(\mathcal{F}_1 \setminus \{p(a, Z_1)\}) \cup \{p(a, Z_2), p(Z_2, Z_2)\})$ \\
     \hline
    3  & $\mathcal{F}_2 \cup \{p(Z_1, Z_4), p(Z_4, Z_4), p(Z_3, Z_5)\}$ & $\mathcal{F}_2$ \\
     \hline
     ... & ... & \\
     \hline
\end{tabular}
\end{center}

On constate qu'à l'étape 2, les algorithmes produisent $p(Z1,Z3)$. La variable $Z_1$ se trouvent donc deux atomes : $p(a,Z_1)$ et $(Z_1, Z_3)$. Cette variable existait déjà à l'étape 1, donc le \textit{local core chase} ne peut pas tenter de la replier, elle fait partie des variables qui ont été gelées. Par contre, le \textit{core chase} peut la replier sur des atomes produits à l'étape 2, car il existe un homomorphisme $h = \{Z_1 \rightarrow Z_2, Z_3 \rightarrow Z_2\} $ tel que $h(\{p(a,Z_1), p(Z_1,Z_3)\}) = \{p(a,Z_2),p(Z_2,Z_2)\}$. Le \textit{core chase} retire donc ces atomes à l'étape 2 et c'est ce qui lui permet de s'arrêter contrairement au \textit{local core chase}.
\end{example}
\par Il est possible d'avoir une autre approche que le calcul d'un \textit{core} pour éliminer plus de redondances que le \textit{restricted chase} : c'est l'approche utilisée par le \textit{vacuum chase}.

\subsubsection{Le \textit{vacuum chase}}\label{sec:vacuum_chase}

Le \textit{vacuum chase} utilise une approche très différente des algorithmes précédents. Mais avant de pouvoir la décrire, il faut introduire la notion de pièce d'un ensemble d'atomes et de pièce (de la tête) d'une règle.
\begin{definition}[Pièce d'un ensemble d'atomes / d'une base de faits]\label{def:piece_atomes}
    On appelle pièce d’un ensemble d'atomes $A$ un sous-ensemble $P$ non vide d’atomes qui vérifie : 
    \begin{itemize}
        \item pour toute variable existentielle $z$ de l'ensemble d'atomes $A$, si un atome contenant $z$ est dans $P$ alors tous les atomes qui contiennent $z$ sont dans $P$ 
        \item $P$ est minimal pour cette propriété.
    \end{itemize}
Le dépiéçage est l'opération consistant à partitionner un ensemble d'atomes $A$ en l'ensemble des pièces contenues dans $A$.
\end{definition}

\begin{definition}[Pièce d'une règle]\label{def:piece_regle}
    On appelle pièce d’une règle une pièce de la tête de la règle (la tête étant un ensemble d'atomes).
    \par Une règle est dite monopièce lorsqu'elle ne contient qu'une seule pièce dans sa tête.
    \par Toute règle peut être transformée en une ou plusieurs règles monopièces. Si on prend une règle $R = B \rightarrow p_1, p_2, \ldots, p_n$ où les $p_i$ sont des pièces, alors l'ensemble des règles $\{R_i = B \rightarrow p_i\}$ est équivalent à $R$ - les $R_i$ permettent d'inférer exactement les mêmes faits que $R$.
\end{definition}
\par On peut maintenant présenter le fonctionnement du \textit{vacuum chase}. Comme les algorithmes précédents, le critère d'applicabilité est celui du \textit{restricted chase}. On va présenter une extension locale et une extension globale spécifiques au \textit{vacuum chase}. Il est cependant à note que cet algorithme est mal défini : on va présenter ici un version possible de cet algorithme, mais on pourra constater, à l'aide d'un exemple, qu'elle n'est pas sans défaut.
\par Pour cette version, l'extension globale consiste, pour chaque pièce $p$ dans la base de faits courante $\mathcal{F}$, à tester l'existence d'un homomorphisme $h$ tel que $p$ s'envoie sur les nouveaux faits ($h(p) \subset nouvFaits$). Si tel est le cas, on retire $p$ de la base de faits courante (algorithme \ref{algo:etendre_global_vacuum_chase}).
\par L'extension locale consiste, pour chaque déclencheur $(R = B \rightarrow H,h)$, à tester pour chaque pièce $p$ de $H$ si il existe une extension $h'$ de $h$ telle que $h'(p) \subset \mathcal{F}$. Si c'est le cas, alors cette pièce n'est pas ajoutée aux nouveaux faits (algorithme \ref{algo:etendre_local_vacuum_chase}). 
\par On peut remarquer que si les règles sont toutes monopièces, alors l'extension locale est équivalente à utiliser le critère du \textit{restricted chase}. En effet, si les règles sont monopièces, alors le critère utilisé dans l'extension locale pour ajouter la pièce aux nouveaux faits a déjà été testé dans le critère d'applicabilité du \textit{restricted chase}. Il est par conséquent possible d'avoir une version du \textit{vacuum chase} utilisant l'extension locale par défaut à condition de rendre les règles monopièces avant de débuter la saturation.


\begin{algorithm}[H]\label{algo:etendre_global_vacuum_chase}
\setstretch{1}
\caption{étendreGlobalement (\textit{vacuum chase} version A)}
\SetAlgoLined
\DontPrintSemicolon
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{$\mathcal{F}$ : la base de faits courante
\par $nouvFaits$ : les nouveaux faits à ajouter}
\Output{la base de faits $\mathcal{F'}$ étendue}
     $\mathcal{F'} \leftarrow \emptyset$\;
	\ForEach{$piece \subset \mathcal{F}$}
    {
        \uIf{$\neg\exists h : h(piece) \subset nouvFaits$}
        {
            $\mathcal{F}' \gets \mathcal{F}' \cup piece$\;
        }
    }
    \Return $\mathcal{F'} \cup nouvFaits$
\end{algorithm}

\begin{algorithm}[H]\label{algo:etendre_local_vacuum_chase}
\setstretch{1}
\caption{étendreLocalement (\textit{vacuum chase} version A)}
\SetAlgoLined
\DontPrintSemicolon
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{
   $nouvFaits$ : les nouveaux faits de l'étape en cours
    \par $(R = B \rightarrow H,h)$ : le déclencheur à appliquer
    \par $\mathcal{F}$ : la base de faits courante}
\Output{l'extension de $nouvFaits$}
    \ForEach{$piece \subset H$}
    {
        \uIf{$\neg\exists$ extension $h'$ de $h : h'(piece) \subset \mathcal{F}$}
        {
            $nouvFaits \gets nouvFaits \cup h^{safe}(piece)$\;
        }
    }
    \Return $nouvFaits$\;
\end{algorithm}

On va maintenant reprendre l'exemple de la base de connaissances $\mathcal{KB}_F = (\mathcal{F} = \{r(a)\}, \mathcal{R} = \{R_1 = r(X) \rightarrow p(X,Z), R_2 = p(X,Y) \rightarrow p(X,Z) \land p(Z,Z), R_3 = p(X,Y) \rightarrow p(Y,Z) \})$ et observer comment cette version du \textit{vacuum chase} se comporte.
\begin{center}
\begin{tabular}{|c|c|c|c|}
    \hline
    $\mathcal{F}$ & \textit{vacuum chase} & \textit{core chase} \\ 
    \hline
    1 & $\mathcal{F} \cup \{ p(a,Z_1)\}$ & $\mathcal{F} \cup \{ p(a,Z_1)\}$\\ 
    \hline
    2  & $(\mathcal{F}_1 \setminus \{p(a, Z_1)\})\cup \{p(a, Z_2), p(Z_2, Z_2), p(Z1, Z_3)\}$ & $(\mathcal{F}_1 \setminus \{p(a, Z_1)\}) \cup \{p(a, Z_2), p(Z_2, Z_2)\})$ \\
     \hline
    3  & $(\mathcal{F}_1 \setminus \{p(Z_1,Z_3)\}) \cup \{p(Z_1, Z_4), p(Z_4, Z_4), p(Z_3, Z_5)\}$ & $\mathcal{F}_2$ \\
     \hline
     ... & ... & \\
     \hline
\end{tabular}
\end{center}
On observe qu'à l'étape 2, l'algorithme retire l'atome $p(a,Z_1)$ après avoir produit à partir de celui-ci $p(Z_1,Z_3)$, qui est un atome redondant. À l'étape suivant, cet atome est retiré, mais ayant avant cela permis de produire tous les nouveaux atomes de cette étape, qui sont aussi redondants. Et l'algorithme continue ainsi à l'infini.
\par Une solution possible est de modifier l'algorithme d'extension globale pour, lorsqu'une variable disparaît de la base de faits, que tous les atomes qui la contiennent soient retirés des nouveaux faits ainsi que tous les atomes dans la même pièce que cette variable. 
\par Une autre solution est une version alternative de cet algorithme, où l'extension globale serait celle de l'\textit{oblivious chase} et tout le travail de suppression des pièces se déroulerait dans l'extension locale (algorithme \ref{algo:etendre_local_vacuum_chase_B}). Cette version est cependant plus lourde en temps de calcul car elle essaie d'envoyer toutes les pièces de la base de faits vers les nouveaux faits lors de chaque application d'un déclencheur, ce qui réduit l'intérêt de cet algorithme. Mais elle présente l'intérêt de s'arrêter de la même façon que le \textit{core chase} sur l'exemple précédent.


\begin{algorithm}[H]\label{algo:etendre_local_vacuum_chase_B}
\setstretch{1}
\caption{étendreLocalement (\textit{vacuum chase} version B)}
\SetAlgoLined
\DontPrintSemicolon
\SetAlgoLined
\DontPrintSemicolon
\SetKwInOut{Input}{entrées}
\SetKwInOut{Output}{sortie}
\Input{
   $nouvFaits$ : les nouveaux faits de l'étape en cours
    \par $(R = B \rightarrow H,h)$ : le déclencheur à appliquer
    \par $\mathcal{F}$ : la base de faits courante}
\Output{l'extension de $nouvFaits$ et la base de faits modifiée $\mathcal{F}'$}
    \ForEach{$piece \subset H$}
    {
        \uIf{$\neg\exists$ extension $h'$ de $h : h'(piece) \subset \mathcal{F}$}
        {
            $nouvFaits \gets nouvFaits \cup h^{safe}(piece)$\;
        }
    }
     $\mathcal{F'} \leftarrow \emptyset$\;
	\ForEach{$piece \subset \mathcal{F}$}
    {
        \uIf{$\neg\exists h : h(piece) \subset nouvFaits$}
        {
            $\mathcal{F}' \gets \mathcal{F}' \cup piece$\;
        }
    }
    \Return $(nouvFaits, \mathcal{F'})$
\end{algorithm}

\par Après avoir présenté différents types de chases, on peut maintenant passer à leur implémentation.
% \begin{algorithm}[H]\label{algo:vacuum_chase}
% \caption{Vacuum chase}
% \SetAlgoLined
% \DontPrintSemicolon

% \SetKwInOut{Input}{entrées}
% \SetKwInOut{Output}{sortie}
% \Input{une base de faits $\mathcal{F}$, une base de règles $\mathcal{R}$}
% \Output{la base de faits saturée $\mathcal{F^*}$}
% \SetKwRepeat{Do}{faire}{tant que}

% $\mathcal{F}_0 \gets \mathcal{F}$\;
% $n \gets 0$\;

% \Do{$\mathcal{F}_n \not=\mathcal{F}_{n+1}$}
% {
%     $nouvFaits\gets \emptyset$ \;
%     \ForEach{$ R = B \rightarrow  H \in \mathcal{R}$} 
%     {
%         \ForEach{(nouvel) homomorphisme $h$ de $B$ dans $\mathcal{F}_n$} 
%         {
%             \uIf{R est applicable d'après le critère du restricted chase en parallèle}
%             {
%                 $A \gets h(H)$\;
%                 $piecesRegle \gets \mbox{dépiécer(A)}$\;
%                 $P \gets \emptyset$\;
                
%                 \ForEach{$piece \in piecesRegle$}
%                 {
%                     \uIf{$\neg\exists$ une extension $g$ de h $: g(piece) \in \mathcal{F}_n$}
%                     {
%                         $P \gets P \cup piece$\;
%                     }
%                 }
%                 $nouvFaits \gets nouvFaits \cup P$\;
                
%                 $piecesF \gets \mbox{\textit{dépiécer}} (\mathcal{F}_n)$\;
                
%                 $\mathcal{F}_n' \gets \emptyset$\;
                
%                 \ForEach{$piece \in piecesF$}
%                 {
%                     \uIf{$\neg\exists g : g(piece) \in P$}
%                     {
%                         $\mathcal{F}_n' \gets \mathcal{F}_n' \cup piece$\;
%                     }
%                 }
                
               
%                 $\mathcal{F}_n \gets \mathcal{F}_n'$\;
%             }
%         }
%     }
%     $\mathcal{F}_{n+1} \gets \mbox{Étendre}(\mathcal{F}_{n}, nouvFaits)$\;
%     $n \gets n + 1$\;
% }
% \Return $\mathcal{F}_n$
% \end{algorithm}

% \subsubsection{Comparaison des chaînages avant}
%%COMMENT
% \begin{comment}



% \begin{example}
% $\mathcal{KB} = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(x,y) \rightarrow q(x,z) \})$
% \begin{center}
%     \begin{tabular}{|c|c|c|c|c|}
%         \hline 
%         $\mathcal{F}$ & Oblivious & Semi-oblivious & Restricted & Core \\
%         \hline 
%         1 & $\mathcal{F} \cup \{q(x,z_1)\}$ & $\mathcal{F} \cup \{q(x,z_1)\}$ & $\mathcal{F} \cup \{q(x,z_1)\}$ & $\mathcal{F} \cup \{q(x,z_1)\}$ \\
%         \hline 
%         2 & $\mathcal{F}_1$ & $\mathcal{F}_1$ & $\mathcal{F}_1$ & $\mathcal{F}_1$ \\
%         \hline 
%     \end{tabular}
% \end{center}
% \end{example}

% \begin{example}
% % oblivious , expl 2
% $\mathcal{KB} = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(x,y) \rightarrow p(x,z) \})$

% \begin{center}
% \begin{tabular}{|c|c|c|c|c|}
%     \hline
%     $\mathcal{F}$ & Oblivious & Semi-oblivious & Restricted & Core \\ 
%     \hline
%     1 &$\mathcal{F} \cup \{p(a, z_1)\}$ & $\mathcal{F} \cup \{p(a, z_1)\} $&  $\mathcal{F}$ &  $\mathcal{F}$\\ 
%     \hline
%     2 &$\mathcal{F}_1 \cup \{p(a, z_2)\}$ &$\mathcal{F}_1$ & &\\
%     \hline
%     ... & ... & & & \\
%     \hline
%     $i+1$ & $\mathcal{F}_i \cup \{p(a, z_{i+1})\} $&  & & \\
%      \hline
%      ... & ... & & & \\
%      \hline
% \end{tabular}
% \end{center}
% \end{example}

% \begin{example}
% % oblivious , expl 3
% $\mathcal{KB} = (\mathcal{F} = \{p(a,a)\}, \mathcal{R} = \{R = p(x,y) \rightarrow p(y,z) \})$

% \begin{center}
% \begin{tabular}{|c|c|c|c|c|}
%     \hline
%     $\mathcal{F}$ & Oblivious & Semi-oblivious & Restricted & Core \\ 
%     \hline
%     1 &$\mathcal{F} \cup \{p(a, z_1)\}$ & $\mathcal{F} \cup \{p(a, z_1)\} $&  $\mathcal{F}$ &  $\mathcal{F}$\\ 
%     \hline
%     2 &$\mathcal{F}_1 \cup \{p(z_1, z_2)\}$ &$\mathcal{F}_1 \cup \{p(z_1, z_2)\}$   &$\mathcal{F}_1$& $\mathcal{F}_1$ \\
%     \hline
%     ... & ... & ... & & \\
%     \hline
%     i+1 & $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1})\} $& $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1})\} $&   & \\
%      \hline
%      ... & ... & ... & & \\
%      \hline
% \end{tabular}
% \end{center}
% \end{example}

% \begin{example}
% % oblivious , expl 4
% $\mathcal{KB} = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R_1 = p(x,y) \rightarrow p(y,z) , R_2 = p(x,y) \rightarrow p(y,y) \})$

% \begin{center}
% \begin{tabular}{|c|c|c|}
%     \hline
%     $\mathcal{F}$ & Oblivious & Semi-oblivious \\ 
%     \hline
%     1 &$\mathcal{F} \cup \{p(b, z_1), p(b,b)\}$ & $\mathcal{F} \cup \{p(b, z_1), p(b,b)\} $\\ 
%     \hline
%     2 &$\mathcal{F}_1 \cup \{p(z_1, z_2), p(z_1, z_1), p(b, z_3)\}$ &$\mathcal{F}_1 \cup \{p(z_1, z_2), p(z_1, z_1)\}$  \\
%     \hline
%     ... & ... & ...  \\
%     \hline
%     i+1 & $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1}), p(z_{i}, z_{i}), p(z_{i-1}), p(z_{i+2}), ...\} $& $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1}), p(z_{i}, z_{i})\} $ \\
%      \hline
%      ... & ... & ... \\
%      \hline
% \end{tabular}
% \begin{tabular}{|c|c|c|c|}
%     \hline
%     $\mathcal{F}$ & Restricted (largeur) R1/R2 & Restricted (largeur) R2/R1 & Core \\ 
%     \hline
%     1 &  $\mathcal{F} \cup \{p(b, z_1), p(b,b)\} $ & $\mathcal{F} \cup \{p(b,b)\}$ & $\mathcal{F} \cup \{ p(b,b)\}$\\ 
%     \hline
%     2 &$\mathcal{F}_1 \cup \{p(z_1, z_2), p(z_1, z_1)\}$& $\mathcal{F}_1$ & $\mathcal{F}_1$ \\
%     \hline
%     ... & ... & & \\
%     \hline
%     i+1 &  $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1}), p(z_{i}, z_{i})\} $  && \\
%      \hline
%      ... &  ... & & \\
%      \hline
% \end{tabular}
% \end{center}
% \end{example}

% %exemple 5 
% \begin{example}
% $\mathcal{KB} = (\mathcal{F} = \{p(a,b)\}, \mathcal{R} = \{R = p(x,y) \rightarrow p(y,z) \})$
% \begin{center}
% \begin{tabular}{|c|c|c|c|c|}
%     \hline
%     $\mathcal{F}$ & O & SO & R & Core \\ 
%     \hline
%     1 & $\mathcal{F} \cup \{p(b, z_0)\} $& $\mathcal{F} \cup \{p(b, z_0)\}$ &  $\mathcal{F} \cup \{p(b, z_0)\}$ &  $\mathcal{F} \cup \{p(b, z_0)\}$\\
%     \hline
%     2 & $\mathcal{F}_1 \cup \{p(z_0, z_1)\}$ & $\mathcal{F}_1 \cup \{p(z_0, z_1)\} $& $\mathcal{F}_1 \cup \{p(z_0, z_1)\}$ & $\mathcal{F}_1 \cup \{p(z_0, z_1)\}$\\ 
%     \hline
%     3 & $\mathcal{F}_2 \cup \{p(z_1, z_2)\}$ & $\mathcal{F}_2 \cup \{p(z_1, z_2)\}$ &  $\mathcal{F}_2 \cup \{p(z_1, z_2)\}$ & $\mathcal{F}_2 \cup \{p(z_1, z_2)\}$\\ 
%     \hline
%     ... &... & ... & ... & ...\\
%     \hline
%     i+1 & $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1})\} $& $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1})\} $& $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1})\} $  & $\mathcal{F}_i \cup \{p(z_{i}, z_{i+1})\} $\\
%     \hline
%     ... &... & ... & ... & ...\\
%     \hline
%     %\mathcal{F}_2 = \mathcal{F}_1 \cup \{p(a, z_2)\} & \mathcal{F}_2 = \mathcal{F}_1 & &\\
%     %\hline
%     %\mathcal{F}_{i+1} = \mathcal{F}_i \cup \{p(a, z_{i+1})\} &  & & \\
%      %\hline
% \end{tabular}
% \end{center}
% \end{example}
% \end{comment}
%END COMMENT

% \begin{example}
% \par
% $\mathcal{KB} = (\mathcal{F} = \{r(a)\}, \mathcal{R} = \{R1 = r(x) \rightarrow p(x,z) , R2 = p(x,y) \rightarrow p(x,z), p(z,z) ,R3 = p(x,y) \rightarrow p(y,z) \})$ (voir figure \ref{fig:ex_local_core}) \\
% \begin{figure}[H]
%     \centering
%     \caption{Local core chase}
% \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,semithick]
%   \tikzstyle{every state}=[circle,text=black,minimum size=0.1cm]

%   \node[state] 						(A)              {$a:r$};
%   \node[state]      			   	(B) [right of=A] {$Z_1$};
%   \node[state]         				(C) [right of=B] {$Z_4$};
%   \node[state]			    		(D) [below of=A] {$Z_2$};
%   \node[state]			    		(E) [below of=B] {$Z_3$};
%   \node[state]			    		(F) [below of=C] {$Z_5$};
%   \node[state]			    		(G) [below of=E] {$Z_6$};
%   \node[state]			    		(H) [below of=F] {$Z_7$};

%   \path (A) edge              					node 		{$p$} 	(B)
%             edge              					node 		{$p$} 	(D)
%         (B) edge 			 					node 		{$p$} 	(E)
%             edge              					node 		{$p$} 	(C)
%         (C) edge [out=60,in=120,looseness=6]    node[above] {$p$} 	(C)
%         (D) edge [out=320,in=40,looseness=6]	node[right] {$p$} 	(D)
        
%         (E) edge 								node 		{$p$} 	(F)
%         	edge 			 					node 		{$p$} 	(G)
%         (F) edge 								node 		{$p$} 	(H)
%         (G) edge [out=320,in=40,looseness=6]	node[right] {$p$} 	(G);
% \end{tikzpicture}
% \label{fig:ex_local_core}
% \end{figure}

% \begin{figure}[H]
%     \centering
%     \caption{Core chase}
%     \vspace{11pt}
% \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,semithick]
%   \tikzstyle{every state}=[circle,text=black,minimum size=0.1cm]

%   \node[state] 						(A)              {$a:r$};
%   \node[state]			    		(D) [below of=A] {$Z_2$};

%   \path (A) edge              					node 		{$p$} 	(D)

%         (D) edge [out=320,in=40,looseness=6]	node[right] {$p$} 	(D);
% \end{tikzpicture}
% \label{fig:ex_core}
% \end{figure}

% $h= \{(a,a),(z_2,z_2),(z_1,z_2),(z_3,z_2) \}$

% \begin{center}
% \begin{tabular}{|c|c|}
%     \hline
%     $\mathcal{F}$ & Atomes \\ 
%     \hline
%     1 & $\mathcal{F} \cup \{p(a, z_1)\} $\\
%     \hline
%     2 & $\{r(a),p(a, z_2),p(z_2, z_2)\} $\\
%     \hline
%     %\mathcal{F}_2 = \mathcal{F}_1 \cup \{p(a, z_2)\} & \mathcal{F}_2 = \mathcal{F}_1 & &\\
%     %\hline
%     %\mathcal{F}_{i+1} = \mathcal{F}_i \cup \{p(a, z_{i+1})\} &  & & \\
%      %\hline
% \end{tabular}
% \end{center}



% \end{example}
%%%%%%%%%%%%%%%%%%COMMENTE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{comment}
% \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
%                 thick,main node/.style={circle,draw,font=\Large\bfseries}]
%   \node[main node] (1) {$a$};
%   \node[main node] (2) [below left of=1] {$Z_0$};
%   \node[main node] (3) [below right of=1] {$Z_1$};
%   \node[main node] (4) [below of=2] {$Z_2$};

%   \path
%     (1) edge [loop above] node {r} (1)
%         edge node {p} (3)
%         edge node {p} (2)
%     (2) edge node {p} (4)
%     (3) edge [loop right] node {p} (3)
% \end{tikzpicture}
% \end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%